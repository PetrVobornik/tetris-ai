<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --panel-bg: #1e293b;
            --accent-color: #38bdf8;
            --text-color: #e2e8f0;
            --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            touch-action: none;
            /* Prevent default touch actions like scrolling */
            user-select: none;
            /* Prevent text selection */
            -webkit-user-select: none;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: 100dvh;
            overflow: hidden;
        }

        .game-container {
            display: flex;
            gap: 2rem;
            padding: 2rem;
            background: var(--panel-bg);
            border-radius: 24px;
            box-shadow: var(--shadow);
            border: 1px solid rgba(255, 255, 255, 0.05);
            max-width: 100vw;
            max-height: 100vh;
            max-height: 100dvh;
        }

        .game-board-wrapper {
            position: relative;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            
            /* Responsive sizing */
            aspect-ratio: 1 / 2;
            height: min(85vh, calc((100vw - 26rem) * 2));
            width: auto;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            min-width: 140px;
        }

        .info-panel {
            background: rgba(15, 23, 42, 0.5);
            padding: 1rem;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #38bdf8 0%, #a855f7 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        h2 {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #94a3b8;
            margin-bottom: 0.5rem;
        }

        .score-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #fff;
        }

        .controls-info {
            font-size: 0.8rem;
            color: #cbd5e1;
            line-height: 1.5;
            text-align: left;
        }

        .key {
            display: inline-block;
            padding: 1px 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-weight: 600;
            margin: 0 2px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.75rem;
        }

        .btn {
            width: auto;
            padding: 1rem;
            border: none;
            border-radius: 12px;
            font-family: inherit;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #38bdf8 0%, #2563eb 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(56, 189, 248, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(56, 189, 248, 0.4);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #b91c1c 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
        }

        .btn-danger:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #cbd5e1;
            padding: 0.5rem 1rem;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .btn-close {
            background: linear-gradient(135deg, #38bdf8 0%, #2563eb 100%);
            color: white;
            margin-top: 1rem;
            width: auto;
            padding: 0.8rem 2rem;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(4px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        .overlay-title {
            font-size: 3rem;
            font-weight: 800;
            color: #fff;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }

        .small-canvas {
            background-color: rgba(15, 23, 42, 0.5);
            border-radius: 4px;
            margin: 0 auto;
            width: 100%;
            height: auto;
        }

        /* Controls Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background: var(--panel-bg);
            padding: 2rem;
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 90%;
            width: 400px;
            text-align: center;
            box-shadow: var(--shadow);
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: var(--accent-color);
        }

        .control-group {
            margin-bottom: 1.5rem;
            text-align: left;
        }

        .control-group h3 {
            font-size: 1rem;
            color: #fff;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.2rem;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: #cbd5e1;
        }

        #controlsBtn {
            display: none;
            /* Hidden on desktop by default */
        }

        @media (max-width: 768px) {
            body {
                align-items: flex-start;
                padding-top: 10px;
            }

            .game-container {
                flex-direction: column;
                align-items: center;
                padding: 0.5rem;
                gap: 0.5rem;
                max-height: 98vh;
                max-height: 98dvh;
            }

            .game-board-wrapper {
                order: 2;
                padding: 5px;
                
                /* Mobile sizing */
                height: min(calc(100vh - 13rem), calc(100dvh - 13rem), calc((100vw - 2rem) * 2));
                width: auto;
                aspect-ratio: 1 / 2;
            }

            #tetris {
                height: 100%;
                width: auto;
            }

            .sidebar {
                min-width: auto;
                width: 100%;
                flex-direction: row;
                justify-content: center;
                gap: 0.5rem;
            }

            .sidebar-left {
                order: 1;
                flex-wrap: nowrap;
            }

            .sidebar-right {
                order: 3;
                flex-wrap: nowrap;
            }

            .info-panel {
                padding: 0.3rem;
                min-width: 60px;
            }

            .info-panel h2 {
                font-size: 0.6rem;
                margin-bottom: 0.2rem;
            }

            .score-value {
                font-size: 1rem;
            }

            .small-canvas {
                width: 60px;
                height: 60px;
            }

            h1 {
                font-size: 1.5rem;
                display: none;
                /* Hide title on mobile to save space */
            }

            /* Hide the static controls panel on mobile */
            #controlsPanel {
                display: none;
            }

            /* Show the controls button on mobile */
            #controlsBtn {
                display: block;
                margin-top: 0;
                padding: 0.5rem;
                font-size: 0.8rem;
                width: auto;
                min-width: 80px;
            }

            #startBtn {
                width: auto;
                padding: 0.5rem 1rem;
                font-size: 0.9rem;
                white-space: nowrap;
            }
        }

        /* Very small screens */
        @media (max-height: 700px) {
            .game-board-wrapper {
                /* max-height: 55vh; */
            }
        }
    </style>
</head>

<body>

    <div class="game-container">
        <!-- Left Sidebar (Priority: Next, Hold, Start) -->
        <div class="sidebar sidebar-left">
            <div class="info-panel">
                <h2>Next</h2>
                <canvas id="next" width="120" height="120" class="small-canvas"></canvas>
            </div>

            <div class="info-panel" id="holdPanel" style="cursor: pointer;">
                <h2>Hold</h2>
                <canvas id="hold" width="120" height="120" class="small-canvas"></canvas>
            </div>

            <button id="startBtn" class="btn btn-primary" tabindex="-1">Start Game</button>
            
            <!-- Fullscreen Toggle (Mobile) -->
            <button id="fullscreenBtn" class="btn btn-secondary" tabindex="-1" title="Toggle Fullscreen">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                </svg>
            </button>
        </div>

        <!-- Main Game Board -->
        <div class="game-board-wrapper">
            <canvas id="tetris" width="300" height="600"></canvas>

            <!-- Game Over Overlay -->
            <div id="gameOver" class="overlay">
                <div class="overlay-title">GAME OVER</div>
                <button id="restartBtn" class="btn btn-primary" style="width: auto; padding: 0.8rem 2rem;"
                    tabindex="-1">Try
                    Again</button>
            </div>

            <!-- Pause Overlay -->
            <div id="pauseScreen" class="overlay">
                <div class="overlay-title">PAUSED</div>
                <button id="resumeBtn" class="btn btn-primary"
                    style="width: auto; padding: 0.8rem 2rem; margin-bottom: 1rem;" tabindex="-1">Resume</button>
                <!-- Removed "Press P to resume" text -->
            </div>
        </div>

        <!-- Right Sidebar (Secondary: Title, Score, Level, Controls) -->
        <div class="sidebar sidebar-right">
            <div>
                <h1>TETRIS</h1>
            </div>

            <div class="info-panel">
                <h2>Score</h2>
                <div id="score" class="score-value">0</div>
            </div>

            <div class="info-panel">
                <h2>Level</h2>
                <div id="level" class="score-value">1</div>
            </div>

            <div class="info-panel" id="controlsPanel">
                <h2>Controls</h2>
                <div class="controls-info">
                    <p><span class="key">←</span> <span class="key">→</span> Move</p>
                    <p><span class="key">↑</span> Rotate</p>
                    <p><span class="key">↓</span> Soft Drop</p>
                    <p><span class="key">Space</span> Hard Drop</p>
                    <p><span class="key">C</span> Hold</p>
                    <p><span class="key">P</span> Pause</p>
                </div>
            </div>

            <!-- Controls Button (Visible only on mobile) -->
            <button id="controlsBtn" class="btn btn-secondary" tabindex="-1">Controls</button>
        </div>
    </div>

    <!-- Controls Modal -->
    <div id="controlsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title">Controls</div>

            <div class="control-group">
                <h3>Keyboard</h3>
                <div class="control-item"><span>Move</span> <span>← →</span></div>
                <div class="control-item"><span>Rotate</span> <span>↑</span></div>
                <div class="control-item"><span>Soft Drop</span> <span>↓</span></div>
                <div class="control-item"><span>Hard Drop</span> <span>Space</span></div>
                <div class="control-item"><span>Hold</span> <span>C</span></div>
                <div class="control-item"><span>Pause</span> <span>P</span></div>
            </div>

            <div class="control-group">
                <h3>Touch</h3>
                <div class="control-item"><span>Move</span> <span>Drag Left/Right</span></div>
                <div class="control-item"><span>Rotate</span> <span>Tap</span></div>
                <div class="control-item"><span>Soft Drop</span> <span>Swipe Down</span></div>
                <div class="control-item"><span>Hard Drop</span> <span>Swipe Up</span></div>
                <div class="control-item"><span>Hold</span> <span>Tap Hold Box</span></div>
            </div>

            <button id="closeControlsBtn" class="btn btn-close">Close</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        const holdCanvas = document.getElementById('hold');
        const holdContext = holdCanvas.getContext('2d');
        const nextCanvas = document.getElementById('next');
        const nextContext = nextCanvas.getContext('2d');

        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const controlsBtn = document.getElementById('controlsBtn');
        const closeControlsBtn = document.getElementById('closeControlsBtn');
        const controlsModal = document.getElementById('controlsModal');
        const holdPanel = document.getElementById('holdPanel');
        const fullscreenBtn = document.getElementById('fullscreenBtn');

        const gameOverOverlay = document.getElementById('gameOver');
        const pauseOverlay = document.getElementById('pauseScreen');

        const ROW = 20;
        const COL = 10;
        const SQ = 30; // Square size
        const VACANT = "#0f172a"; // Matches canvas background

        // Sound Manager
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const Sound = {
            playTone: (freq, type, duration) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            move: () => Sound.playTone(200, 'triangle', 0.05),
            rotate: () => Sound.playTone(300, 'sine', 0.05),
            drop: () => Sound.playTone(100, 'square', 0.1),
            clear: () => {
                Sound.playTone(400, 'sine', 0.1);
                setTimeout(() => Sound.playTone(600, 'sine', 0.1), 100);
                setTimeout(() => Sound.playTone(800, 'sine', 0.2), 200);
            },
            gameOver: () => {
                Sound.playTone(150, 'sawtooth', 0.5);
                setTimeout(() => Sound.playTone(100, 'sawtooth', 0.5), 400);
            }
        };

        // Draw a square
        function drawSquare(x, y, color, ctx = context) {
            ctx.fillStyle = color;
            ctx.fillRect(x * SQ, y * SQ, SQ, SQ);

            // Add a slight bevel/border effect for 3D look
            ctx.strokeStyle = "rgba(255,255,255,0.1)";
            ctx.lineWidth = 1;
            ctx.strokeRect(x * SQ, y * SQ, SQ, SQ);

            // Inner glow
            ctx.fillStyle = "rgba(255,255,255,0.1)";
            ctx.fillRect(x * SQ + 2, y * SQ + 2, SQ - 4, SQ - 4);

            ctx.fillStyle = color; // Reset for next fill
            ctx.fillRect(x * SQ + 4, y * SQ + 4, SQ - 8, SQ - 8);
        }

        // Draw Ghost Square
        function drawGhostSquare(x, y, color) {
            context.strokeStyle = color;
            context.lineWidth = 2;
            context.strokeRect(x * SQ, y * SQ, SQ, SQ);
            context.fillStyle = "rgba(255, 255, 255, 0.05)";
            context.fillRect(x * SQ, y * SQ, SQ, SQ);
        }

        // Create the board
        let board = [];

        function createBoard() {
            board = [];
            for (let r = 0; r < ROW; r++) {
                board[r] = [];
                for (let c = 0; c < COL; c++) {
                    board[r][c] = VACANT;
                }
            }
        }

        // Draw the board
        function drawBoard() {
            for (let r = 0; r < ROW; r++) {
                for (let c = 0; c < COL; c++) {
                    drawSquare(c, r, board[r][c]);
                }
            }
        }

        // Piece definitions
        const I = [
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
            [[0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]],
            [[0, 0, 0, 0], [0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0]],
            [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]]
        ];
        const J = [
            [[1, 0, 0], [1, 1, 1], [0, 0, 0]],
            [[0, 1, 1], [0, 1, 0], [0, 1, 0]],
            [[0, 0, 0], [1, 1, 1], [0, 0, 1]],
            [[0, 1, 0], [0, 1, 0], [1, 1, 0]]
        ];
        const L = [
            [[0, 0, 1], [1, 1, 1], [0, 0, 0]],
            [[0, 1, 0], [0, 1, 0], [0, 1, 1]],
            [[0, 0, 0], [1, 1, 1], [1, 0, 0]],
            [[1, 1, 0], [0, 1, 0], [0, 1, 0]]
        ];
        const O = [
            [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]
        ];
        const S = [
            [[0, 1, 1], [1, 1, 0], [0, 0, 0]],
            [[0, 1, 0], [0, 1, 1], [0, 0, 1]],
            [[0, 0, 0], [0, 1, 1], [1, 1, 0]],
            [[1, 0, 0], [1, 1, 0], [0, 1, 0]]
        ];
        const T = [
            [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
            [[0, 1, 0], [0, 1, 1], [0, 1, 0]],
            [[0, 0, 0], [1, 1, 1], [0, 1, 0]],
            [[0, 1, 0], [1, 1, 0], [0, 1, 0]]
        ];
        const Z = [
            [[1, 1, 0], [0, 1, 1], [0, 0, 0]],
            [[0, 0, 1], [0, 1, 1], [0, 1, 0]],
            [[0, 0, 0], [1, 1, 0], [0, 1, 1]],
            [[0, 1, 0], [1, 1, 0], [1, 0, 0]]
        ];

        // The pieces and their colors
        const PIECES = [
            [Z, "#ef4444"],
            [S, "#22c55e"],
            [T, "#a855f7"],
            [O, "#eab308"],
            [L, "#f97316"],
            [I, "#38bdf8"],
            [J, "#3b82f6"]
        ];

        // The Object Piece
        class Piece {
            constructor(tetromino, color) {
                this.tetromino = tetromino;
                this.color = color;
                this.tetrominoN = 0; // Start from the first pattern
                this.activeTetromino = this.tetromino[this.tetrominoN];

                // Control the starting position
                this.x = 3;
                this.y = -2;
            }

            // Fill function
            fill(color) {
                for (let r = 0; r < this.activeTetromino.length; r++) {
                    for (let c = 0; c < this.activeTetromino.length; c++) {
                        // We draw only occupied squares
                        if (this.activeTetromino[r][c]) {
                            drawSquare(this.x + c, this.y + r, color);
                        }
                    }
                }
            }

            // Draw the piece to the board
            draw() {
                this.fill(this.color);
                this.drawGhost();
            }

            // Undraw the piece
            unDraw() {
                this.fill(VACANT);
                // Also undraw ghost
                let ghostY = this.y;
                while (!this.collision(0, 1, this.activeTetromino, ghostY)) {
                    ghostY++;
                }
                for (let r = 0; r < this.activeTetromino.length; r++) {
                    for (let c = 0; c < this.activeTetromino.length; c++) {
                        if (this.activeTetromino[r][c]) {
                            drawSquare(this.x + c, ghostY + r, VACANT);
                        }
                    }
                }
                // Redraw board to cover any gaps
                drawBoard();
            }

            drawGhost() {
                let ghostY = this.y;
                // Find lowest valid position
                while (!this.collision(0, 1, this.activeTetromino, ghostY)) {
                    ghostY++;
                }

                for (let r = 0; r < this.activeTetromino.length; r++) {
                    for (let c = 0; c < this.activeTetromino.length; c++) {
                        if (this.activeTetromino[r][c]) {
                            // Only draw ghost if it's not overlapping with the active piece
                            if (ghostY + r >= 0) {
                                drawGhostSquare(this.x + c, ghostY + r, this.color);
                            }
                        }
                    }
                }
                // Redraw the actual piece on top to ensure it's visible
                this.fill(this.color);
            }

            // Move Down
            moveDown() {
                if (!this.collision(0, 1, this.activeTetromino)) {
                    this.unDraw();
                    this.y++;
                    this.draw();
                } else {
                    // Lock the piece and generate a new one
                    this.lock();
                    p = nextPiece;
                    nextPiece = randomPiece();
                    drawNextPiece();
                    canHold = true; // Reset hold ability
                }
            }

            // Move Right
            moveRight() {
                if (!this.collision(1, 0, this.activeTetromino)) {
                    this.unDraw();
                    this.x++;
                    this.draw();
                }
            }

            // Move Left
            moveLeft() {
                if (!this.collision(-1, 0, this.activeTetromino)) {
                    this.unDraw();
                    this.x--;
                    this.draw();
                }
            }

            // Rotate
            rotate() {
                let nextPattern = this.tetromino[(this.tetrominoN + 1) % this.tetromino.length];
                let kick = 0;

                if (this.collision(0, 0, nextPattern)) {
                    if (this.x > COL / 2) {
                        // It's the right wall
                        kick = -1; // Move left
                    } else {
                        // It's the left wall
                        kick = 1; // Move right
                    }
                }

                if (!this.collision(kick, 0, nextPattern)) {
                    this.unDraw();
                    this.x += kick;
                    this.tetrominoN = (this.tetrominoN + 1) % this.tetromino.length;
                    this.activeTetromino = this.tetromino[this.tetrominoN];
                    this.draw();
                    Sound.rotate();
                }
            }

            // Hard Drop
            hardDrop() {
                this.unDraw();
                while (!this.collision(0, 1, this.activeTetromino)) {
                    this.y++;
                    score += 2; // Bonus for hard drop
                }
                this.draw();
                this.lock();
                p = nextPiece;
                nextPiece = randomPiece();
                drawNextPiece();
                canHold = true;
            }

            lock() {
                Sound.drop();
                for (let r = 0; r < this.activeTetromino.length; r++) {
                    for (let c = 0; c < this.activeTetromino.length; c++) {
                        // Skip vacant squares
                        if (!this.activeTetromino[r][c]) {
                            continue;
                        }
                        // Pieces to lock on top = Game Over
                        if (this.y + r < 0) {
                            // Game Over
                            isGameOver = true;
                            gameOverOverlay.classList.add('visible');
                            Sound.gameOver();
                            cancelAnimationFrame(animationId);
                            return;
                        }
                        // Lock the piece
                        board[this.y + r][this.x + c] = this.color;
                    }
                }
                // Remove full rows
                for (let r = 0; r < ROW; r++) {
                    let isRowFull = true;
                    for (let c = 0; c < COL; c++) {
                        isRowFull = isRowFull && (board[r][c] != VACANT);
                    }
                    if (isRowFull) {
                        // If the row is full
                        // Move down all the rows above it
                        for (let y = r; y > 1; y--) {
                            for (let c = 0; c < COL; c++) {
                                board[y][c] = board[y - 1][c];
                            }
                        }
                        // The top row board[0][..] has no row above it
                        for (let c = 0; c < COL; c++) {
                            board[0][c] = VACANT;
                        }
                        // Increment the score
                        score += 10;
                        linesCleared++;
                        if (linesCleared % 10 === 0) {
                            level++;
                            dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                        }
                        Sound.clear();
                    }
                }
                // Update the board
                drawBoard();
                scoreElement.innerHTML = score;
                levelElement.innerHTML = level;
            }

            // Collision function
            collision(x, y, piece, overrideY = null) {
                for (let r = 0; r < piece.length; r++) {
                    for (let c = 0; c < piece.length; c++) {
                        // If the square is empty, we skip it
                        if (!piece[r][c]) {
                            continue;
                        }
                        // Coordinates of the piece after movement
                        let newX = this.x + c + x;
                        let newY = (overrideY !== null ? overrideY : this.y) + r + y;

                        // Conditions
                        if (newX < 0 || newX >= COL || newY >= ROW) {
                            return true;
                        }
                        // Skip checking negative Y (above board)
                        if (newY < 0) {
                            continue;
                        }
                        // Check if there is a locked piece already in place
                        if (board[newY][newX] != VACANT) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }

        function randomPiece() {
            let r = Math.floor(Math.random() * PIECES.length);
            return new Piece(PIECES[r][0], PIECES[r][1]);
        }

        function drawNextPiece() {
            nextContext.fillStyle = VACANT;
            nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

            const offsetX = (4 - nextPiece.activeTetromino.length) / 2;
            const offsetY = (4 - nextPiece.activeTetromino.length) / 2;

            for (let r = 0; r < nextPiece.activeTetromino.length; r++) {
                for (let c = 0; c < nextPiece.activeTetromino.length; c++) {
                    if (nextPiece.activeTetromino[r][c]) {
                        drawSquare(c + offsetX, r + offsetY, nextPiece.color, nextContext);
                    }
                }
            }
        }

        function drawHoldPiece() {
            holdContext.fillStyle = VACANT;
            holdContext.fillRect(0, 0, holdCanvas.width, holdCanvas.height);

            if (!holdPiece) return;

            // Center the piece
            const offsetX = (4 - holdPiece.activeTetromino.length) / 2;
            const offsetY = (4 - holdPiece.activeTetromino.length) / 2;

            for (let r = 0; r < holdPiece.activeTetromino.length; r++) {
                for (let c = 0; c < holdPiece.activeTetromino.length; c++) {
                    if (holdPiece.activeTetromino[r][c]) {
                        drawSquare(c + offsetX, r + offsetY, holdPiece.color, holdContext);
                    }
                }
            }
        }

        let p;
        let nextPiece;
        let holdPiece = null;
        let canHold = true;

        let score = 0;
        let level = 1;
        let linesCleared = 0;
        let isGameOver = false;
        let dropStart = Date.now();
        let dropInterval = 1000; // 1 second
        let animationId;
        let isPaused = false;

        function drop() {
            if (isPaused || isGameOver) return;

            let now = Date.now();
            let delta = now - dropStart;

            if (delta > dropInterval) {
                p.moveDown();
                dropStart = Date.now();
            }

            if (!isGameOver) {
                animationId = requestAnimationFrame(drop);
            }
        }

        function togglePause() {
            if (isGameOver) return;
            isPaused = !isPaused;

            if (isPaused) {
                pauseOverlay.classList.add('visible');
                cancelAnimationFrame(animationId);
                // Update Start Button to Restart (Red)
                startBtn.innerText = "Restart";
                startBtn.classList.remove('btn-primary');
                startBtn.classList.add('btn-danger');
            } else {
                pauseOverlay.classList.remove('visible');
                drop();
                // Update Start Button to Pause (Blue)
                startBtn.innerText = "Pause";
                startBtn.classList.remove('btn-danger');
                startBtn.classList.add('btn-primary');
            }
        }

        function hold() {
            if (!canHold) return;

            if (!holdPiece) {
                holdPiece = p;
                p = nextPiece;
                nextPiece = randomPiece();
                drawNextPiece();
            } else {
                let temp = p;
                p = holdPiece;
                holdPiece = temp;
            }

            // Reset position and rotation
            p.x = 3;
            p.y = -2;
            p.tetrominoN = 0;
            p.activeTetromino = p.tetromino[0];

            canHold = false;
            holdPiece.x = 3; // Reset hold piece coords just in case
            holdPiece.y = -2;

            drawHoldPiece();
            p.draw(); // Will redraw board + ghost + new piece
            Sound.move();
        }

        function initGame() {
            createBoard();
            drawBoard();
            score = 0;
            level = 1;
            linesCleared = 0;
            dropInterval = 1000;
            scoreElement.innerHTML = score;
            levelElement.innerHTML = level;
            isGameOver = false;
            isPaused = false;
            gameOverOverlay.classList.remove('visible');
            pauseOverlay.classList.remove('visible');

            // Reset Start Button to Pause state
            startBtn.innerText = "Pause";
            startBtn.classList.remove('btn-danger');
            startBtn.classList.add('btn-primary');

            holdPiece = null;
            canHold = true;
            drawHoldPiece();

            p = randomPiece();
            nextPiece = randomPiece();
            drawNextPiece();

            p.draw();
            dropStart = Date.now();
            if (animationId) cancelAnimationFrame(animationId);
            drop();
        }

        startBtn.addEventListener('click', () => {
            startBtn.blur(); // Remove focus immediately
            if (isPaused && !isGameOver && p) {
                // If paused, this button acts as Restart
                initGame();
            } else if (!p || isGameOver) {
                // Start new game
                initGame();
            } else {
                // Game is running, act as Pause
                togglePause();
            }
        });

        resumeBtn.addEventListener('click', () => {
            resumeBtn.blur();
            togglePause();
        });

        restartBtn.addEventListener('click', () => {
            restartBtn.blur();
            initGame();
        });

        // Controls Modal Logic
        controlsBtn.addEventListener('click', () => {
            controlsModal.classList.add('visible');
            if (!isPaused && !isGameOver && p) {
                togglePause(); // Auto pause when opening controls
            }
        });

        closeControlsBtn.addEventListener('click', () => {
            controlsModal.classList.remove('visible');
        });

        // Hold Click Logic
        holdPanel.addEventListener('click', () => {
            if (!isPaused && !isGameOver) {
                hold();
            }
        });

        // Fullscreen Logic
        fullscreenBtn.addEventListener('click', () => {
            fullscreenBtn.blur();
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        // Control function
        function CONTROL(event) {
            if (isGameOver || isPaused) {
                if (event.keyCode == 80) { // P for Pause (allow unpause)
                    togglePause();
                }
                return;
            }

            if (event.keyCode == 37) {
                p.moveLeft();
                dropStart = Date.now();
            } else if (event.keyCode == 38) {
                p.rotate();
                dropStart = Date.now();
            } else if (event.keyCode == 39) {
                p.moveRight();
                dropStart = Date.now();
            } else if (event.keyCode == 40) {
                p.moveDown();
            } else if (event.keyCode == 32) {
                p.hardDrop();
            } else if (event.keyCode == 67) { // C for Hold
                hold();
            } else if (event.keyCode == 80) { // P for Pause
                togglePause();
            }
        }

        document.addEventListener("keydown", CONTROL);

        // Touch Controls
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        let initialPieceX = 0;
        let isDragging = false;

        document.addEventListener('touchstart', function (event) {
            if (isPaused || isGameOver) return;
            touchStartX = event.changedTouches[0].screenX;
            touchStartY = event.changedTouches[0].screenY;
            if (p) {
                initialPieceX = p.x;
            }
            isDragging = false;
        }, false);

        document.addEventListener('touchmove', function (event) {
            if (event.target.tagName !== 'BUTTON') {
                event.preventDefault(); // Prevent scrolling
            }

            if (isPaused || isGameOver || !p) return;

            let touchX = event.changedTouches[0].screenX;
            let touchY = event.changedTouches[0].screenY;

            let diffX = touchX - touchStartX;
            let diffY = touchY - touchStartY;

            // Visual Square Size approximation (Canvas width / Columns)
            const rect = canvas.getBoundingClientRect();
            const visualSQ = rect.width / COL;

            // Horizontal Dragging (1:1 tracking)
            if (!isDragging) {
                if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
                    isDragging = true;
                }
            }

            if (isDragging) {
                // Calculate target column based on initial position + drag distance
                let colOffset = Math.round(diffX / visualSQ);
                let targetX = initialPieceX + colOffset;

                // Move piece towards targetX
                while (p.x < targetX) {
                    let prevX = p.x;
                    p.moveRight();
                    if (p.x === prevX) break; // Blocked
                }
                while (p.x > targetX) {
                    let prevX = p.x;
                    p.moveLeft();
                    if (p.x === prevX) break; // Blocked
                }
            }

        }, { passive: false });

        document.addEventListener('touchend', function (event) {
            touchEndX = event.changedTouches[0].screenX;
            touchEndY = event.changedTouches[0].screenY;

            if (isPaused || isGameOver) return;

            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;
            const absDiffX = Math.abs(diffX);
            const absDiffY = Math.abs(diffY);

            // Threshold for swipe vs tap
            const threshold = 30;

            if (!isDragging && absDiffX < threshold && absDiffY < threshold) {
                // Tap - Rotate
                p.rotate();
                dropStart = Date.now();
            } else if (!isDragging) {
                // If we weren't dragging horizontally, check for vertical swipes
                if (absDiffY > absDiffX && absDiffY > threshold) {
                    if (diffY > 0) {
                        // Down - Soft Drop
                        p.moveDown();
                    } else {
                        // Up - Hard Drop
                        p.hardDrop();
                    }
                }
            }

            isDragging = false;
        }, false);

        // Initial draw
        createBoard();
        drawBoard();

        // Init canvases
        holdContext.fillStyle = VACANT;
        holdContext.fillRect(0, 0, holdCanvas.width, holdCanvas.height);
        nextContext.fillStyle = VACANT;
        nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

    </script>
</body>

</html>