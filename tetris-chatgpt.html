<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris – single‑file (HTML + CSS + JS)</title>
  <style>
    :root{
      --bg:#0f1220; --panel:#181c2f; --accent:#4aa3ff; --grid:#202642; --text:#e8edff;
      --cell-size:32px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;
      background:radial-gradient(1200px 800px at 70% -20%, #1c2246 0%, #0f1220 60%);
      color:var(--text); display:flex; align-items:center; justify-content:center;
    }
    .wrap{display:grid; grid-template-columns:auto 1fr auto; gap:18px; width:min(1100px, 96vw); padding:18px}
    .panel{background:var(--panel); border:1px solid #23294a; border-radius:16px; padding:14px; box-shadow:0 6px 18px rgba(0,0,0,.35)}
    h1{font-size:18px; margin:0 0 8px 0; font-weight:700; letter-spacing:.3px}

    /* Playfield */
    .stage{ position:relative; }
    .grid{
      display:grid; grid-template-columns:repeat(10, var(--cell-size));
      grid-template-rows:repeat(20, var(--cell-size)); gap:1px; background:var(--grid);
      padding:1px; border-radius:10px; box-shadow:inset 0 0 0 1px #2a315e;
    }
    .cell{ width:var(--cell-size); height:var(--cell-size); background:#0b0f26; border-radius:6px }
    .cell.f{ box-shadow: inset 0 8px 0 rgba(255,255,255,.08), inset 0 -8px 14px rgba(0,0,0,.5) }

    /* Pieces colors */
    .cI{ background:#00e5ff }
    .cJ{ background:#3b82f6 }
    .cL{ background:#f59e0b }
    .cO{ background:#fcd34d; color:#333 }
    .cS{ background:#10b981 }
    .cT{ background:#a855f7 }
    .cZ{ background:#ef4444 }
    .ghost{ outline:2px dashed rgba(255,255,255,.25); }
    .ghost:not(.f){ background:transparent }

    /* Side panels */
    .side{ width:220px; display:flex; flex-direction:column; gap:14px }
    .stats p{ margin:.2rem 0; font-variant-numeric:tabular-nums }
    .meter{ height:8px; background:#0c1030; border-radius:999px; overflow:hidden; box-shadow:inset 0 0 0 1px #2a315e }
    .meter > span{ display:block; height:100%; background:linear-gradient(90deg, #4aa3ff, #34d399); width:0 }

    .mini{ display:grid; grid-template-columns:repeat(4, 20px); grid-template-rows:repeat(4,20px); gap:2px; background:#1a1f3d; padding:6px; border-radius:10px }
    .mini div{ width:20px; height:20px; background:#0b0f26; border-radius:4px }

    /* Controls */
    .controls{ display:grid; grid-template-columns:repeat(5,1fr); gap:8px }
    .btn{
      background:#151936; border:1px solid #2a315e; border-radius:12px; padding:10px 8px; color:var(--text);
      font-weight:600; text-align:center; cursor:pointer; user-select:none; transition:transform .08s ease, filter .08s ease
    }
    .btn:active{ transform:translateY(1px); filter:brightness(1.1) }
    .kbd{ font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding:.08rem .35rem; border:1px solid #3a4072; border-radius:6px; background:#0f1330 }

    /* Header help */
    .help{ font-size:13px; opacity:.8 }

    /* Responsive */
    @media (max-width: 900px){
      :root{ --cell-size:28px }
      .side{ width:190px }
    }
    @media (max-width: 760px){
      .wrap{ grid-template-columns:1fr }
      .stage{ order:-1 }
      .side{ width:auto; order:0 }
      body{ align-items:flex-start; padding-top: calc(12px + env(safe-area-inset-top, 0px)); }
      /* Reorder side panels on mobile */
      .controlsPanel{ order:1 }
      .nextPanel{ order:2 }
      .holdPanel{ order:3 }
      .stats{ order:4 }
    }
      .side{ width:auto; order:0 }
      body{ align-items:flex-start; padding-top: calc(12px + env(safe-area-inset-top, 0px)); }
    }
      .side{ width:auto; order:-1 }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="side">
      <div class="panel stats">
        <h1>Tetris</h1>
        <p>Skóre: <strong id="score">0</strong></p>
        <p>Řádky: <strong id="lines">0</strong></p>
        <p>Level: <strong id="level">1</strong></p>
        <div class="meter" aria-label="Postup na další level"><span id="lvlprog" style="width:0%"></span></div>
        <p class="help">Ovládání: <span class="kbd">←</span><span class="kbd">→</span> pohyb, <span class="kbd">↓</span> pád,
          <span class="kbd">↑</span>/<span class="kbd">Z</span> otočit, <span class="kbd">Space</span> tvrdý pád,
          <span class="kbd">C</span> držet, <span class="kbd">P</span> pauza, <span class="kbd">R</span> restart.
        </p>
      </div>
      <div class="panel holdPanel">
        <h1>Držák</h1>
        <div id="hold" class="mini" aria-label="Držený kámen"></div>
      </div>
      <div class="panel nextPanel">
        <h1>Následuje</h1>
        <div id="next" style="display:flex; gap:10px">
          <div class="mini"></div>
          <div class="mini"></div>
          <div class="mini"></div>
        </div>
      </div>
      <div class="panel controlsPanel">
        <h1>Dotykové ovládání</h1>
        <div class="controls">
          <div class="btn" data-act="left">◀︎</div>
          <div class="btn" data-act="rotateL">⟲</div>
          <div class="btn" data-act="drop">⬇︎⬇︎</div>
          <div class="btn" data-act="rotateR">⟳</div>
          <div class="btn" data-act="right">▶︎</div>
          <div class="btn" style="grid-column: span 2" data-act="down">⬇︎</div>
          <div class="btn" style="grid-column: span 2" data-act="hold">HOLD</div>
          <div class="btn" data-act="pause">⏯</div>
        </div>
      </div>
    </div>

    <div class="panel stage">
      <div id="grid" class="grid" aria-label="Hrací pole"></div>
      <div id="overlay" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none">
        <div id="banner" style="display:none; background:rgba(15,18,32,.9); padding:18px 24px; border:1px solid #2a315e; border-radius:14px; text-align:center">
          <div id="bannerText" style="font-size:24px; font-weight:800; margin-bottom:8px">PAUZA</div>
          <div style="opacity:.8">Stiskněte <span class="kbd">P</span> pro pokračování</div>
        </div>
      </div>
    </div>
  </div>

  <script>
  // ====== TETRIS CORE ======
  (()=>{
    const W=10,H=20;
    const gridEl=document.getElementById('grid');
    const scoreEl=document.getElementById('score');
    const linesEl=document.getElementById('lines');
    const levelEl=document.getElementById('level');
    const lvlprog=document.getElementById('lvlprog');
    const holdEl=document.getElementById('hold');
    const nextEls=[...document.querySelectorAll('#next .mini')];
    const banner=document.getElementById('banner');
    const bannerText=document.getElementById('bannerText');

    // Build DOM cells once
    const cells=[];
    for(let i=0;i<W*H;i++){ const d=document.createElement('div'); d.className='cell'; gridEl.appendChild(d); cells.push(d); }

    // Tetromino definitions (relative coords per rotation)
    const PIECES={
      I:{c:'cI', r:[[[0,1],[1,1],[2,1],[3,1]], [[2,0],[2,1],[2,2],[2,3]], [[0,2],[1,2],[2,2],[3,2]], [[1,0],[1,1],[1,2],[1,3]]]},
      J:{c:'cJ', r:[[[0,0],[0,1],[1,1],[2,1]], [[1,0],[2,0],[1,1],[1,2]], [[0,1],[1,1],[2,1],[2,2]], [[1,0],[1,1],[0,2],[1,2]]]},
      L:{c:'cL', r:[[[2,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[1,2],[2,2]], [[0,1],[1,1],[2,1],[0,2]], [[0,0],[1,0],[1,1],[1,2]]]},
      O:{c:'cO', r:[[[1,0],[2,0],[1,1],[2,1]], [[1,0],[2,0],[1,1],[2,1]], [[1,0],[2,0],[1,1],[2,1]], [[1,0],[2,0],[1,1],[2,1]]]},
      S:{c:'cS', r:[[[1,0],[2,0],[0,1],[1,1]], [[1,0],[1,1],[2,1],[2,2]], [[1,1],[2,1],[0,2],[1,2]], [[0,0],[0,1],[1,1],[1,2]]]},
      T:{c:'cT', r:[[[1,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[2,1],[1,2]], [[0,1],[1,1],[2,1],[1,2]], [[1,0],[0,1],[1,1],[1,2]]]},
      Z:{c:'cZ', r:[[[0,0],[1,0],[1,1],[2,1]], [[2,0],[1,1],[2,1],[1,2]], [[0,1],[1,1],[1,2],[2,2]], [[1,0],[0,1],[1,1],[0,2]]]},
    };
    const TYPES=Object.keys(PIECES);

    // State
    let board=Array.from({length:H},()=>Array(W).fill(0));
    let score=0, lines=0, level=1;
    let bag=[]; let nextQueue=[];
    let cur=null; // {type,x,y,rot,locked}
    let hold=null; let canHold=true;
    let timer=0; let dropInterval=1000; let lastTime=0; let paused=false; let gameOver=false;

    const lineScore=[0,100,300,500,800];

    function newBag(){
      const a=[...TYPES];
      for(let i=a.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [a[i],a[j]]=[a[j],a[i]]; }
      bag=bag.concat(a);
    }
    function ensureNext(n=3){ while(nextQueue.length<n){ if(bag.length===0) newBag(); nextQueue.push(bag.shift()); } }

    function spawn(){
      ensureNext();
      const type=nextQueue.shift(); ensureNext();
      const piece={type, x:3, y:-1, rot:0};
      if(collision(board,piece,piece.x,piece.y,piece.rot)){ // try spawn at y=0
        piece.y=0;
      }
      cur=piece; canHold=true;
      if(collision(board,cur,cur.x,cur.y,cur.rot)){
        gameOver=true; paused=true; showBanner('KONEC HRY');
      }
      drawSide();
    }

    function collision(b,p,x,y,r){
      const cells=PIECES[p.type].r[r];
      for(const [dx,dy] of cells){
        const cx=x+dx, cy=y+dy;
        if(cy<0) continue; // allow spawn area
        if(cx<0||cx>=W||cy>=H) return true;
        if(b[cy][cx]) return true;
      }
      return false;
    }

    function merge(){
      const col=PIECES[cur.type].c;
      for(const [dx,dy] of PIECES[cur.type].r[cur.rot]){
        const x=cur.x+dx, y=cur.y+dy;
        if(y>=0) board[y][x]=col;
      }
    }

    function clearLines(){
      let cleared=0;
      for(let y=H-1;y>=0;y--){
        if(board[y].every(v=>v)){ board.splice(y,1); board.unshift(Array(W).fill(0)); cleared++; y++; }
      }
      if(cleared){
        lines+=cleared; score+=lineScore[cleared]*(level);
        // Level every 10 lines
        const prevLevel=level;
        level=1+Math.floor(lines/10);
        dropInterval=Math.max(100, 1000 - (level-1)*80);
        if(level!==prevLevel) pulseMeter();
        updateHUD();
      }
    }

    function softDrop(){ cur.y++; if(collision(board,cur,cur.x,cur.y,cur.rot)){ cur.y--; lock(); } else { score+=1; updateHUD(); } }
    function hardDrop(){ let d=0; while(!collision(board,cur,cur.x,cur.y+1,cur.rot)){ cur.y++; d++; } score+=d*2; lock(); }

    function lock(){ merge(); clearLines(); spawn(); }

    function rotate(dir){
      if(cur.type==='O') return; // O does not need rotation kicks
      const old=cur.rot; const r=(old + (dir>0?1:3))%4;
      const kicks=[[0,0],[1,0],[-1,0],[2,0],[-2,0],[0,-1]]; // simple kicks
      for(const [kx,ky] of kicks){
        if(!collision(board,cur,cur.x+kx,cur.y+ky,r)){ cur.x+=kx; cur.y+=ky; cur.rot=r; return; }
      }
      // try small upward kick for tight spots
      if(!collision(board,cur,cur.x,cur.y-1,r)){ cur.y-=1; cur.rot=r; }
    }

    function move(dx){ if(!collision(board,cur,cur.x+dx,cur.y,cur.rot)) cur.x+=dx; }
    function tick(dt){ if(paused||gameOver) return; timer+=dt; if(timer>dropInterval){ timer%=dropInterval; if(!collision(board,cur,cur.x,cur.y+1,cur.rot)) cur.y++; else lock(); } }

    function getGhostY(){ let y=cur.y; while(!collision(board,cur,cur.x,y+1,cur.rot)) y++; return y; }

    function draw(){
      // Clear
      for(const c of cells){ c.className='cell'; }
      // Board
      for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
          const v=board[y][x]; if(v){ const idx=y*W+x; cells[idx].classList.add('f', v); }
        }
      }
      // Ghost
      const gy=getGhostY();
      PIECES[cur.type].r[cur.rot].forEach(([dx,dy])=>{
        const x=cur.x+dx, y=gy+dy; if(y>=0){ cells[y*W+x].classList.add('ghost'); }
      });
      // Current piece
      PIECES[cur.type].r[cur.rot].forEach(([dx,dy])=>{
        const x=cur.x+dx, y=cur.y+dy; if(y>=0){ const el=cells[y*W+x]; el.classList.add('f', PIECES[cur.type].c); }
      });
    }

    function updateHUD(){ scoreEl.textContent=score; linesEl.textContent=lines; levelEl.textContent=level; lvlprog.style.width=( (lines%10)/10*100 )+"%"; }

    function drawMini(container, type){
      container.innerHTML='';
      const blocks=[]; for(let i=0;i<16;i++){ const d=document.createElement('div'); container.appendChild(d); blocks.push(d); }
      if(!type) return;
      const cells=PIECES[type].r[0];
      // center shape within 4x4 by minimal x,y
      const minx=Math.min(...cells.map(c=>c[0])); const miny=Math.min(...cells.map(c=>c[1]));
      cells.forEach(([dx,dy])=>{ const x=dx-minx, y=dy-miny; const idx=y*4+x; blocks[idx].style.background='currentColor'; blocks[idx].style.color='inherit'; blocks[idx].classList.add(PIECES[type].c); blocks[idx].style.borderRadius='4px'; });
    }

    function drawSide(){
      // hold
      drawMini(holdEl, hold);
      // next 3
      nextEls.forEach((el,i)=> drawMini(el, nextQueue[i]||null));
    }

    function holdSwap(){
      if(!canHold) return;
      if(hold==null){ hold=cur.type; spawn(); }
      else { const t=hold; hold=cur.type; cur={type:t, x:3, y:0, rot:0}; if(collision(board,cur,cur.x,cur.y,cur.rot)){ gameOver=true; paused=true; showBanner('KONEC HRY'); } }
      canHold=false; drawSide();
    }

    function showBanner(text){ bannerText.textContent=text; banner.style.display='block'; }
    function hideBanner(){ banner.style.display='none'; }

    function togglePause(){ if(gameOver) return; paused=!paused; if(paused) showBanner('PAUZA'); else hideBanner(); }
    function restart(){ board=Array.from({length:H},()=>Array(W).fill(0)); score=0; lines=0; level=1; dropInterval=1000; bag=[]; nextQueue=[]; hold=null; canHold=true; paused=false; gameOver=false; hideBanner(); ensureNext(); spawn(); updateHUD(); draw(); }

    // Keyboard
    const keyState={};
    document.addEventListener('keydown',e=>{
      if(e.repeat) return; keyState[e.code]=true;
      switch(e.code){
        case 'ArrowLeft': move(-1); break;
        case 'ArrowRight': move(1); break;
        case 'ArrowDown': softDrop(); break;
        case 'ArrowUp': rotate(1); break;
        case 'KeyZ': rotate(-1); break;
        case 'Space': e.preventDefault(); hardDrop(); break;
        case 'KeyC': holdSwap(); break;
        case 'KeyP': togglePause(); break;
        case 'KeyR': restart(); break;
      }
      draw();
    });

    // Simple DAS/ARR for left/right/down holding
    let moveAccum=0, moveDir=0, downHeld=false;
    document.addEventListener('keyup',e=>{ keyState[e.code]=false; if(e.code==='ArrowLeft' && moveDir<0) moveDir=0; if(e.code==='ArrowRight' && moveDir>0) moveDir=0; if(e.code==='ArrowDown') downHeld=false; });
    document.addEventListener('keydown',e=>{
      if(e.code==='ArrowLeft'){ moveDir=-1; moveAccum=0; }
      if(e.code==='ArrowRight'){ moveDir=1; moveAccum=0; }
      if(e.code==='ArrowDown'){ downHeld=true; }
    });

    // Touch controls
    document.querySelectorAll('.btn').forEach(b=>{
      const act=b.getAttribute('data-act');
      const fire=()=>{
        if(act==='left') move(-1);
        else if(act==='right') move(1);
        else if(act==='down') softDrop();
        else if(act==='drop') hardDrop();
        else if(act==='rotateL') rotate(-1);
        else if(act==='rotateR') rotate(1);
        else if(act==='hold') holdSwap();
        else if(act==='pause') togglePause();
        draw();
      };
      b.addEventListener('click', fire);
      b.addEventListener('touchstart', e=>{ e.preventDefault(); fire(); }, {passive:false});
    });

    function pulseMeter(){ lvlprog.animate([{transform:'scaleX(1.05)'},{transform:'scaleX(1)'}], {duration:300}); }

    // Game loop
    function loop(ts){
      if(!lastTime) lastTime=ts; const dt=ts-lastTime; lastTime=ts;
      // auto move repeat
      if(moveDir!==0){ moveAccum+=dt; const delay=140, repeat=35; if(moveAccum>delay){ const steps=((moveAccum-delay)/repeat)|0; if(steps>0){ for(let i=0;i<steps;i++) move(moveDir); moveAccum=delay + ((moveAccum-delay) % repeat); } }
      }
      if(downHeld && !paused) { // accelerate gravity
        timer+=dt*4; // 4x faster
      }
      tick(dt); draw();
      requestAnimationFrame(loop);
    }

    // Init
    restart();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
